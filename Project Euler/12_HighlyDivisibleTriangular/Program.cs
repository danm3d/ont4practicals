using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;

namespace P12_HighlyDivisibleTriangular {
	/// <summary>
	/// From: https://projecteuler.net/problem=12
	/// The sequence of triangle numbers is generated by adding the natural numbers. 
	/// So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. 
	/// The first ten terms would be:
	/// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
	/// </summary>

	class Program {
		//performance measurement
		private static TimeSpan ts;
		private static long tickCounter;

		static void Main(string[] args) {
			Console.WriteLine("Regular:");
			TriangularNumDivisors();
			Console.WriteLine("Threaded:");
			ParallelTriangularNumDivisors();
			Console.ReadLine();
		}
		static void TriangularNumDivisors() {
			long num = 0L;
			long i = 1L;
			Stopwatch stw = new Stopwatch();
			stw.Start();
			while (FindDivisorsOfTriangularNumber(num) < 500) {
				num += i;
				i++;
			}
			stw.Stop();
			ts = stw.Elapsed;
			tickCounter = stw.ElapsedTicks;
			string elapsed = String.Format("{0:000 000 000}ms", ts.TotalMilliseconds);
			Console.WriteLine("Triangular number with 500 divisors: {0} \nTime:\t{1} \nTicks:\t{2}", num, elapsed, tickCounter);
		}
		static void ParallelTriangularNumDivisors() {
			long num = 0L;
			long i = 1L;
			Stopwatch stw = new Stopwatch();
			stw.Start();
			while (ParallelFindDivisorsOfTriangularNumber(num) < 500) {
				num += i;
				i++;
			}
			stw.Stop();
			ts = stw.Elapsed;
			tickCounter = stw.ElapsedTicks;
			string elapsed = String.Format("{0:000 000 000}ms", ts.TotalMilliseconds);
			Console.WriteLine("Triangular number with 500 divisors: {0} \nTime:\t{1} \nTicks:\t{2}", num, elapsed, tickCounter);

		}


		static long FindDivisorsOfTriangularNumber(long triNum) {
			long divCount;
			divCount = 0;
			long squareRoot = (long)Math.Sqrt(triNum);
			for (int i = 1; i <= squareRoot; i++) {
				if ((triNum % i) == 0) {
					divCount += 2;
				}
			}
			if (squareRoot * squareRoot == triNum) {
				divCount--;
			}
			return divCount;
		}
		static long ParallelFindDivisorsOfTriangularNumber(long triNum) {
			long divCount;

			divCount = 0;
			long squareRoot = (long)Math.Sqrt(triNum);
			Parallel.For(1L, squareRoot, i =>
			{
				if ((triNum % i) == 0) {
					divCount += 2;
				}
			});
			if (squareRoot * squareRoot == triNum) {
				divCount--;
			}

			return divCount;
		}



	}
}
